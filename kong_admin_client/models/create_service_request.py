# coding: utf-8

"""
    Kong Admin API

    OpenAPI 3.0 spec for Kong Gateway's open source Admin API.  You can know more about Kong Gateway at [docs.konghq.com](https://docs.konghq.com) .Give Kong a star at [Kong/kong](https://github.com/kong/kong) repository.

    The version of the OpenAPI document: 3.5.0
    Contact: docs@konghq.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List, Optional
from pydantic import BaseModel, StrictBool, StrictInt, StrictStr, field_validator
from pydantic import Field
from kong_admin_client.models.create_service_request_client_certificate import CreateServiceRequestClientCertificate
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class CreateServiceRequest(BaseModel):
    """
    CreateServiceRequest
    """ # noqa: E501
    name: Optional[StrictStr] = Field(default=None, description="The service name. ")
    retries: Optional[StrictInt] = Field(default=5, description="The number of retries to execute upon failure to proxy. Default:`5`. ")
    protocol: StrictStr = Field(description="The protocol used to communicate with the upstream. Accepted values are: \"`grpc`\", \"`grpcs`\", \"`http`\", \"`https`\", \"`tcp`\", \"`tls`\", \"`tls_passthrough`\", \"`udp`\", \"`ws`\" , \"`wss`\" . Default: \"`http`\".")
    host: StrictStr = Field(description="The host of the upstream server. Note that the host value is case sensitive. ")
    port: StrictInt = Field(description="The upstream server port. Default: `80`. ")
    path: Optional[StrictStr] = Field(default=None, description="The path to be used in requests to the upstream server. ")
    connect_timeout: Optional[StrictInt] = Field(default=6000, description="The timeout in milliseconds for establishing a connection to the upstream server.")
    write_timeout: Optional[StrictInt] = Field(default=6000, description="The timeout in milliseconds between two successive write operations for transmitting a request to the upstream server. Default: `60000`. ")
    read_timeout: Optional[StrictInt] = Field(default=6000, description="The timeout in milliseconds between two successive read operations for transmitting a request to the upstream server. Default: `60000`. ")
    tags: Optional[List[StrictStr]] = Field(default=None, description="An optional set of strings associated with the service for grouping and filtering. ")
    client_certificate: Optional[CreateServiceRequestClientCertificate] = None
    tls_verify: Optional[StrictBool] = Field(default=True, description="Whether to enable verification of upstream server TLS certificate. If set to null, then the Nginx default is respected. ")
    tls_verify_depth: Optional[StrictStr] = Field(default=None, description="Maximum depth of chain while verifying Upstream server's TLS certificate. If set to null, then the Nginx default is respected. Default: null. ")
    ca_certificates: Optional[List[StrictStr]] = Field(default=None, description="Array of CA Certificate object UUIDs that are used to build the trust store while verifying upstream server's TLS certificate. If set to null when Nginx default is respected.  With form-encoded, the notation is `ca_certificates[]=4e3ad2e4-0bc4-4638-8e34-c84a417ba39b&ca_certificates[]=51e77dc2-8f3e-4afa-9d0e-0e3bbbcfd515`. With JSON, use an Array. ")
    enabled: StrictBool = Field(description="Whether the service is active. If set to `false`, the proxy behavior will be as if any routes attached to it do not exist (404). Default: `true`. ")
    __properties: ClassVar[List[str]] = ["name", "retries", "protocol", "host", "port", "path", "connect_timeout", "write_timeout", "read_timeout", "tags", "client_certificate", "tls_verify", "tls_verify_depth", "ca_certificates", "enabled"]

    @field_validator('protocol')
    def protocol_validate_enum(cls, value):
        """Validates the enum"""
        if value not in ('grpc', 'grpcs', 'http', 'https', 'tcp', 'tls ', 'tls_passthrough', 'udp', 'ws', 'wss'):
            raise ValueError("must be one of enum values ('grpc', 'grpcs', 'http', 'https', 'tcp', 'tls ', 'tls_passthrough', 'udp', 'ws', 'wss')")
        return value

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of CreateServiceRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of client_certificate
        if self.client_certificate:
            _dict['client_certificate'] = self.client_certificate.to_dict()
        # set to None if tls_verify_depth (nullable) is None
        # and model_fields_set contains the field
        if self.tls_verify_depth is None and "tls_verify_depth" in self.model_fields_set:
            _dict['tls_verify_depth'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of CreateServiceRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "name": obj.get("name"),
            "retries": obj.get("retries") if obj.get("retries") is not None else 5,
            "protocol": obj.get("protocol") if obj.get("protocol") is not None else 'http',
            "host": obj.get("host"),
            "port": obj.get("port") if obj.get("port") is not None else 80,
            "path": obj.get("path"),
            "connect_timeout": obj.get("connect_timeout") if obj.get("connect_timeout") is not None else 6000,
            "write_timeout": obj.get("write_timeout") if obj.get("write_timeout") is not None else 6000,
            "read_timeout": obj.get("read_timeout") if obj.get("read_timeout") is not None else 6000,
            "tags": obj.get("tags"),
            "client_certificate": CreateServiceRequestClientCertificate.from_dict(obj.get("client_certificate")) if obj.get("client_certificate") is not None else None,
            "tls_verify": obj.get("tls_verify") if obj.get("tls_verify") is not None else True,
            "tls_verify_depth": obj.get("tls_verify_depth"),
            "ca_certificates": obj.get("ca_certificates"),
            "enabled": obj.get("enabled") if obj.get("enabled") is not None else True
        })
        return _obj


