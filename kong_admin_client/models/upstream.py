# coding: utf-8

"""
    Kong Admin API

    OpenAPI 3.0 spec for Kong Gateway's open source Admin API.  You can know more about Kong Gateway at [docs.konghq.com](https://docs.konghq.com) .Give Kong a star at [Kong/kong](https://github.com/kong/kong) repository.

    The version of the OpenAPI document: 3.5.0
    Contact: docs@konghq.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List, Optional
from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
from pydantic import Field
from kong_admin_client.models.upstream_client_certificate import UpstreamClientCertificate
from kong_admin_client.models.upstream_healthchecks import UpstreamHealthchecks
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class Upstream(BaseModel):
    """
    The upstream object represents a virtual hostname and can be used to loadbalance incoming requests over multiple services (targets). So for example an upstream named `service.v1.xyz` for a service object whose `host` is `service.v1.xyz`. Requests for this service would be proxied to the targets defined within the upstream. An upstream also includes a health check, which is able to enable and disable targets based on their ability or inability to serve requests. The configuration for the health checker is stored in the upstream object, and applies to all of its targets.
    """ # noqa: E501
    algorithm: Optional[StrictStr] = Field(default='round-robin', description="Which load balancing algorithm to use.")
    client_certificate: Optional[UpstreamClientCertificate] = None
    created_at: Optional[StrictInt] = Field(default=None, description="Unix epoch when the resource was created.")
    hash_fallback: Optional[StrictStr] = Field(default='none', description="What to use as hashing input if the primary `hash_on` does not return a hash (eg. header is missing, or no Consumer identified). Not available if `hash_on` is set to `cookie`.")
    hash_fallback_header: Optional[StrictStr] = Field(default=None, description="The header name to take the value from as hash input. Only required when `hash_fallback` is set to `header`.")
    hash_fallback_query_arg: Optional[StrictStr] = Field(default=None, description="The name of the query string argument to take the value from as hash input. Only required when `hash_fallback` is set to `query_arg`.")
    hash_fallback_uri_capture: Optional[StrictStr] = Field(default=None, description="The name of the route URI capture to take the value from as hash input. Only required when `hash_fallback` is set to `uri_capture`.")
    hash_on: Optional[StrictStr] = Field(default='none', description="What to use as hashing input. Using `none` results in a weighted-round-robin scheme with no hashing.")
    hash_on_cookie: Optional[StrictStr] = Field(default=None, description="The cookie name to take the value from as hash input. Only required when `hash_on` or `hash_fallback` is set to `cookie`. If the specified cookie is not in the request, Kong will generate a value and set the cookie in the response.")
    hash_on_cookie_path: Optional[StrictStr] = Field(default='/', description="The cookie path to set in the response headers. Only required when `hash_on` or `hash_fallback` is set to `cookie`.")
    hash_on_header: Optional[StrictStr] = Field(default=None, description="The header name to take the value from as hash input. Only required when `hash_on` is set to `header`.")
    hash_on_query_arg: Optional[StrictStr] = Field(default=None, description="The name of the query string argument to take the value from as hash input. Only required when `hash_on` is set to `query_arg`.")
    hash_on_uri_capture: Optional[StrictStr] = Field(default=None, description="The name of the route URI capture to take the value from as hash input. Only required when `hash_on` is set to `uri_capture`.")
    healthchecks: Optional[UpstreamHealthchecks] = None
    host_header: Optional[StrictStr] = Field(default=None, description="The hostname to be used as `Host` header when proxying requests through Kong.")
    id: Optional[StrictStr] = None
    name: Optional[StrictStr] = Field(default=None, description="This is a hostname, which must be equal to the `host` of a service.")
    slots: Optional[StrictInt] = Field(default=10000, description="The number of slots in the load balancer algorithm. If `algorithm` is set to `round-robin`, this setting determines the maximum number of slots. If `algorithm` is set to `consistent-hashing`, this setting determines the actual number of slots in the algorithm. Accepts an integer in the range `10`-`65536`.")
    tags: Optional[List[StrictStr]] = Field(default=None, description="An optional set of strings associated with the Upstream for grouping and filtering.")
    use_srv_name: Optional[StrictBool] = Field(default=False, description="If set, the balancer will use SRV hostname(if DNS Answer has SRV record) as the proxy upstream `Host`.")
    __properties: ClassVar[List[str]] = ["algorithm", "client_certificate", "created_at", "hash_fallback", "hash_fallback_header", "hash_fallback_query_arg", "hash_fallback_uri_capture", "hash_on", "hash_on_cookie", "hash_on_cookie_path", "hash_on_header", "hash_on_query_arg", "hash_on_uri_capture", "healthchecks", "host_header", "id", "name", "slots", "tags", "use_srv_name"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of Upstream from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of client_certificate
        if self.client_certificate:
            _dict['client_certificate'] = self.client_certificate.to_dict()
        # override the default output from pydantic by calling `to_dict()` of healthchecks
        if self.healthchecks:
            _dict['healthchecks'] = self.healthchecks.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of Upstream from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "algorithm": obj.get("algorithm") if obj.get("algorithm") is not None else 'round-robin',
            "client_certificate": UpstreamClientCertificate.from_dict(obj.get("client_certificate")) if obj.get("client_certificate") is not None else None,
            "created_at": obj.get("created_at"),
            "hash_fallback": obj.get("hash_fallback") if obj.get("hash_fallback") is not None else 'none',
            "hash_fallback_header": obj.get("hash_fallback_header"),
            "hash_fallback_query_arg": obj.get("hash_fallback_query_arg"),
            "hash_fallback_uri_capture": obj.get("hash_fallback_uri_capture"),
            "hash_on": obj.get("hash_on") if obj.get("hash_on") is not None else 'none',
            "hash_on_cookie": obj.get("hash_on_cookie"),
            "hash_on_cookie_path": obj.get("hash_on_cookie_path") if obj.get("hash_on_cookie_path") is not None else '/',
            "hash_on_header": obj.get("hash_on_header"),
            "hash_on_query_arg": obj.get("hash_on_query_arg"),
            "hash_on_uri_capture": obj.get("hash_on_uri_capture"),
            "healthchecks": UpstreamHealthchecks.from_dict(obj.get("healthchecks")) if obj.get("healthchecks") is not None else None,
            "host_header": obj.get("host_header"),
            "id": obj.get("id"),
            "name": obj.get("name"),
            "slots": obj.get("slots") if obj.get("slots") is not None else 10000,
            "tags": obj.get("tags"),
            "use_srv_name": obj.get("use_srv_name") if obj.get("use_srv_name") is not None else False
        })
        return _obj


